#!/usr/bin/env python

#*************************************************************************/
#*    simulate the event generated by the standard candle                */ 
# This needs some updating!  I want to make it more modular, so you can  */
# Generate all MC samples with one script.  This requires some parameters*/
# to be set in reference to number of photons and SC1 and SC2 locations. */
#*************************************************************************/  

from I3Tray import *
#from I3Units import *
from glob import glob
from math import *
from os.path import expandvars

from icecube import icetray, dataclasses, dataio, WaveCalibrator
from icecube import phys_services
from icecube.WaveCalibrator import DOMSimulatorCalibrator
from icecube.sim_services.sim_utils.gcd_utils import get_time

import os
import sys

from icecube.BadDomList import bad_dom_list_static


#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=#
#        USER CONTROLS AND VARIABLES SHOULD BE SPECIFIED HERE            #
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=#

# Random number gen seed
seed = 75

# Number of events
#eve_num = 1000; 
eve_num = 5; 

# name of ouput file 
# This only contains partial name
# which will be modified below when
# user specifies the luminosity
physfile = "../i3files/SC2_spicemie_hole100cm"
rootfile = "../trees/SC2_spicemie_hole100cm"
luminosity = 0

# set the detector information you want to implemented in ROMEO # 
GDOMname = "TA0003"

# User options
if len(sys.argv) < 1:
	print "To run script.py <number> where number can be 1, 3, 10, 30, 51, or 100"
	sys.exit(0)
try:
	luminosity = int(sys.argv[1])
except:
	print "1st argument must be integer"
	sys.exit(0)

allowedLumi = [1,3,10,30,51,100]
if luminosity not in allowedLumi:
	print "Luminosity not supported: ", luminosity
	print "Allowed: ", allowedLumi
	sys.exit(0)

physfile += "_" + str(luminosity) + "per.i3.gz"
rootfile += "_" + str(luminosity) + "per.root"

# Specify the num of photons
numPhotons = 0
if   luminosity == 1:  numPhotons = 1.8e11 # 1% 
elif luminosity == 3:  numPhotons = 3.7e11 # 3%
elif luminosity == 10: numPhotons = 1.0e12 # 10%
elif luminosity == 30: numPhotons = 3.0e12 # 30%
elif luminosity == 51: numPhotons = 4.3e12 # 51%
else:                  numPhotons = 1.1e13 # 100%

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=#
#                         END USER SETTINGS                              #
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=#

load("libicetray")
load("libdataclasses")
load("libphys-services")
load("libdataio")
load("libc2j-icetray")
load("libromeo")
load("libromeo-interface")
load("libI3Db")
#load("libDOMcalibrator")
load("libDOMsimulator")
load("libSC-generator")
load("libbrutus")
load("libDomTools")
load("libportia")
load("libtree-maker")
load("libtrigger-sim")
load('wavedeform')
load("libphotonics-service")


def DrivingTime( frame ):
       if "DrivingTime" in frame :
               del frame["DrivingTime"]
       frame.Put("DrivingTime", time )



tray = I3Tray()

# set gcs file #
#gcddir = "/misc/home/mase/work/I3/analysis/SC/process/V04-00-00RC1/"
#gcdfile = gcddir + "GeoCalibDetectorStatus_IC79.55380_corrected_WC.i3.gz"
gcddir = "GCDFiles/"
gcdfile = gcddir + "Level2_IC86.2012_data_Run00120946_1116_GCD.i3.gz"
print "Using GCDFile: " + gcdfile


#
# Add services
#

tray.AddService("I3SPRNGRandomServiceFactory","random")(
        ("Seed",seed), # Seed for random number generator
        ("NStreams",500), # Number of streams used in cluster
        ("StreamNum",1) # Thread number for this generator
)

tray.AddService('I3PhotoSplineServiceFactory', 'photonics-service',
                AmplitudeTable='/misc/home/mase/work/I3/analysis/SC/process/photonics_tables/v173/SC2_SPICEMIE/data/new/sc2_mie.absfits',
		TimingTable='/misc/home/mase/work/I3/analysis/SC/process/photonics_tables/v173/SC2_SPICEMIE/data/new/sc2_mie.probfits',
#		AmplitudeTable='/misc/disk0/data/spline_table/ems_spice1_z20_a10.abs.fits',
#		TimingTable='/misc/disk0/data/spline_table/ems_spice1_z20_a10.prob.fits',
                TimingSigma=0)

#tray.AddService("I3PhotonicsServiceFactory","photonics-service")(
#	("PhotonicsTableSelection", 1), # cascade only                                     
#	("TablesDirectory", "/home/mase/work/I3/EHE/trunk_new/src/"),
#	("DriverFileDirectory", "/home/mase/work/I3/EHE/trunk_new/src/"),
#	("PhotonicsLevel1DriverFile","level1_SC2_100cmtable_newtrunk.list"),
#	("PhotonicsLevel2DriverFile", "level2_table.list"),
#	)




#                                                                                         
# IceTray modules                                                                         
#                                                                                         
tray.AddModule("I3InfiniteSource", "somanyevents",
               Prefix= gcdfile,
               Stream=icetray.I3Frame.DAQ)

time = get_time( dataio.I3File(gcdfile))

tray.AddModule( DrivingTime, "dt",
                Streams = [icetray.I3Frame.DAQ])


tray.AddModule("I3MCEventHeaderGenerator","time-gen")(
    ("Year",time.utc_year),
    ("DAQTime",time.utc_daq_time)
    )

# SC-generator #
tray.AddModule("I3SCGenerator","generator")(
        ("NumPhotons", numPhotons), # set the intensity of SC output 
	("xPosition",11.87*I3Units.m),
	("yPosition",179.19*I3Units.m),
        ("zPosition",-205.64*I3Units.m)
	)

# brutus #
tray.AddModule("I3HitMakerModuleEHE","hit-maker")(
	("MCTreeName","I3MCTree"),
	("MaxMCHits", 500000) # standard EHE analysis = 500k,  special analysis = 50000k   
)

# romeo-interface #
tray.AddModule("I3RomeoInterfaceModule","romeo")(
	("SkipPhotoCathodeSimulator", False),          # Do the 2D photocathod simulation
        ("StoreFakeRecoPulseMap", False),              # skip to store IceCubePMTPulse 
	("RomeoOutputTimeResolution", 10.*I3Units.ns), # must same as MCHitBinSize of I3MCHitCompressor
        ("RomeoSquarePulseThreshold",10),              # output squqre pulse when 10 p.e. or more
        ("StoreRomeoInfo",False),                      # Do not store the Romeo info.   
	("ModelPMTname",GDOMname)      # GDOM PMTname TA1052/TA1059/TA1167 etc
	)

# DOMsimulator #
tray.AddModule("I3DOMsimulator","domsimulator")(
	("SimulatePedestalDroop", True)
)


tray.AddModule("I3DOMLaunchCleaning","BadDomCleaning")(
       ("InIceInput", "InIceRawData"),
       ("IceTopInput", "IceTopRawData"),
       ("InIceOutput", "CleanInIceRawData"),
       ("IceTopOutput", "CleanIceTopRawData"),
       ("FirstLaunchCleaning",False),
       ("CleanedKeysList",""),
       ("IcePickServiceKey",""),
       ("CleanedKeys",bad_dom_list_static.IC86_static_bad_dom_list())
       )

tray.AddModule("I3DOMLaunchCleaning","LaunchCleaning")(
       ("InIceInput", "CleanInIceRawData"),
       ("IceTopInput", "CleanIceTopRawData"),
       ("InIceOutput", "CleanInIceRawDataWODC"),
       ("IceTopOutput", "CleanIceTopRawDataWODC"),
       ("FirstLaunchCleaning",True),
       ("CleanedKeysList",""),
       ("IcePickServiceKey","")
       #("CleanedKeys",[OMKey(a,b) for a in range(79, 87) for b in range(1, 61)])
       )

tray.AddModule("SimpleMajorityTrigger","smtrigger") (
       ("DataReadoutName", "CleanInIceRawDataWODC"),
       ("TriggerConfigID", 1006)
       )

tray.AddModule("I3GlobalTriggerSim","globaltrigger")(
       ("I3DOMLaunchSeriesMapNames", ["CleanInIceRawDataWODC", "CleanIceTopRawDataWODC"])
       )

tray.AddModule("I3Pruner","pruner")(
       ("DOMLaunchSeriesMapNames", ["CleanInIceRawDataWODC", "CleanIceTopRawDataWODC"])
       )


tray.AddModule("I3TimeShifter","timeshifter")(
       ("I3DoubleNames",["dmadd_multtime","dmadd_stringmulttime"]),
       ("I3DOMLaunchSeriesMapNames",["InIceRawData","IceTopRawData","CleanInIceRawData","CleanIceTopRawData","CleanInIceRawDataWODC","CleanIceTopRawDataWODC"]),
       ("I3MCPMTResponseMapNames",["MCPMTResponseMap"]),
       ("I3MCTreeNames",["I3MCTree"]),
       ("I3MCHitSeriesMapNames",["MCHitSeriesMap"]),
       )

tray.AddModule("I3LCCleaning","InIceLCClean")(
       ("IcePickServiceKey",""),
       ("InIceInput", "CleanInIceRawDataWODC"),
       ("InIceOutput", "HLCCleanInIceRawDataWODC"),
       ("InIceOutputSLC", "SLCInIceRawData")   #SLC                                       
       )

tray.AddSegment(DOMSimulatorCalibrator, 'calibrator',
                Launches='HLCCleanInIceRawDataWODC', Waveforms='EHECalibratedWaveforms',
                DOMsimulatorWorkArounds=True, FADCSaturationMargin=1,
                CorrectDroop=False
                )

tray.AddModule("I3WaveformSplitter", "ehewaveformsplit")(
       ("Input","EHECalibratedWaveforms"),
       ("HLC_ATWD","EHECalibratedATWD"),
       ("HLC_FADC","EHECalibratedFADC"),
       ("SLC","EHEGarbage"),
       ("Force",True),
       ("PickUnsaturatedATWD", True)
       )

tray.AddModule("I3NullSplitter", "fullevent")

tray.AddModule( "I3Portia", "OfflinePortiaPulseExtractor") (
    ( "DataReadoutName",            "HLCCleanInIceRawDataWODC" ),
    ( "OutPortiaEventName",         "EHESummaryPulseInfo" ),
    ( "MakeIceTopPulse",             False ),
    ( "ATWDPulseSeriesName",        "ATWDPulseSeries" ),
    ( "ATWDPortiaPulseName",        "ATWDPortiaPulse" ),
    ( "ATWDWaveformName",           "EHECalibratedATWD" ),
    ( "ATWDBaseLineOption",         "eheoptimized" ),
    ( "FADCBaseLineOption",         "eheoptimized" ),
    ( "ATWDThresholdCharge",        0.1 * I3Units.pC ),
    ( "ATWDLEThresholdAmplitude",   0.5 * I3Units.mV ),
    ( "UseFADC",                    True ),
    ( "FADCPulseSeriesName",        "FADCPulseSeries" ),
    ( "FADCPortiaPulseName",        "FADCPortiaPulse" ),
    ( "FADCWaveformName",           "EHECalibratedFADC" ),
    ( "FADCThresholdCharge",        0.1 * I3Units.pC ),
    ( "FADCLEThresholdAmplitude",   0.5 * I3Units.mV ),
    ( "MakeBestPulseSeries",        False ),
    ( "PMTGain",                    10000000),
    )

tray.AddModule( "I3Portia", "OfflinePortiaBestPulseExtractor") (
    ( "DataReadoutName",            "HLCCleanInIceRawDataWODC" ),
    ( "OutPortiaEventName",         "EHESummaryBestPulseInfo" ),
    ( "MakeIceTopPulse",             False ),
    ( "ATWDPulseSeriesName",        "ATWDBestPulseSeries" ),
    ( "ATWDPortiaPulseName",        "ATWDBestPortiaPulse" ),
    ( "ATWDWaveformName",           "EHECalibratedATWD" ),
    ( "ATWDBaseLineOption",         "eheoptimized" ),
    ( "FADCBaseLineOption",         "eheoptimized" ),
    ( "ATWDThresholdCharge",        0.1 * I3Units.pC ),
    ( "ATWDLEThresholdAmplitude",   0.5 * I3Units.mV ),
    ( "UseFADC",                    True ),
    ( "FADCPulseSeriesName",        "FADCBestPulseSeries" ),
    ( "FADCPortiaPulseName",        "FADCBestPortiaPulse" ),
    ( "FADCWaveformName",           "EHECalibratedFADC" ),
    ( "FADCThresholdCharge",        0.1 * I3Units.pC ),
    ( "FADCLEThresholdAmplitude",   0.5 * I3Units.mV ),
    ( "MakeBestPulseSeries",        True ),
    ( "PMTGain",                    10000000),
    )

tray.AddModule( "I3EHEFirstGuess", "EheFirstGuess" ) (
    ( "InputLaunchName",             "HLCCleanInIceRawDataWODC" ),
    ( "InputPortiaEventName",        "EHESummaryBestPulseInfo" ),
    ( "MinimumNumberPulseDom",       8 ),
    ( "OutputFirstguessName",        "OpheliaFirstGuess" ),
    ( "OutputFirstguessNameBtw",     "OpheliaFirstGuessBTW" ),
    ( "InputPulseName1",             "ATWDBestPortiaPulse" ),
    ( "InputPulseName2",             "FADCBestPortiaPulse" ),
    ( "ChargeOption",                0 ),
    ( "LCOption",                    True ),
    )

tray.AddModule( "I3OpheliaConvertFirstGuessTrack", "FirstGuessConverter" ) (
    ( "InputOpheliaFGTrackName",     "OpheliaFirstGuessBTW" ),
    ( "OutputParticleName",          "OpheliaFGParticleBTW" ),
    )


tray.AddModule("I3TreeMakerModule","tree-maker")(
    ("outTreeName",             "JulietTree"),
    ("outFileName",             rootfile),

    ("doJulietTree",           True),
    ("inMCTreeName",           "I3MCTree"),
    ("frameMCWeightName",      "JulietWeightDict"),
    ("frameCosmicRayEnergyWeightName", "CosmicRayEnergyDist"),
    ("framePropagationMatrixVectorName","PropagationMatrix"),
    ("inAtmosphericMuonFluxName","ElbertModelIC22"),

    ("doNuGenTree",            False),
    ("doStdParticleTree",      False),
#    ("inRecoParticleName",     "SPEFit12WCSRT"),                                         
#    ("inRecoParticleParameterName",  "SPEFit12WCSRTFitParams"),                          

    ("doMCHitTree",            True),
    ("inMCHitSeriesName",      "MCHitSeriesMap"),
    ("McHitCompressionOption", True),

    ("useThinWeight",          False),
    ("thinMuWeightName",       "I3ThinMuWeight"),

    ("doDetectorTree",          True),
    ("inDOMLaunchName",         "HLCCleanInIceRawDataWODC"),
    ("doPulseChannelTree",      True),
    ("inAtwdPortiaName",        "ATWDBestPortiaPulse"),
    ("inFadcPortiaName",        "FADCBestPortiaPulse"),
    ("inPortiaEventName",       "EHESummaryBestPulseInfo"),
    ("doWaveformDraw",           False),

    ("doFirstGuessTree",        True),
    ("inFirstguessName",        "OpheliaFirstGuess"),
    ("inFirstguessNameBtw",     "OpheliaFirstGuessBTW"),

    ("doMMCTree",              False),
    ("inMMCTrackListName",     "MMCTrackList"),

    ("doEheStarTree",           False),
    ("doTopTree",               False),

    ("doAddPulseEventTree",     True),
    ("inAddPulseEventName",     "EHESummaryPulseInfo"),                               
    ("inAddDOMLaunchName",      "HLCCleanInIceRawDataWODC")                    
)


tray.AddModule("I3Writer","writer", filename = physfile,
#               DropOrphanStreams=[icetray.I3Frame.DAQ],                                  
               Streams=[icetray.I3Frame.DAQ, icetray.I3Frame.Physics],
               skipkeys=["CleanIceTopRawData", "CleanIceTopRawDataWODC","CleanInIceRawData", "CleanInIceRawDataWODC", "EHECalibratedATWD", "EHECalibratedFADC", "MCPMTResponseMap", "EHECalibratedWaveforms"]
               )


				    
tray.AddModule("Dump","dump")
tray.AddModule("TrashCan", "the can")

tray.Execute(eve_num)

tray.Finish()
